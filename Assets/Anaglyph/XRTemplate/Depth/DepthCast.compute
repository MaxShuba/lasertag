// https://github.com/oculus-samples/Unity-DepthAPI/issues/16
#include "DepthKit.hlsl"

#pragma kernel CSMain

struct RaycastResult
{
	float ZDepthDiff;
	float3 Position;
	float3 Normal;
};

#if defined(SHADER_API_D3D11) 
#define FLIP_UVS 1 
#endif

StructuredBuffer<float3> RaycastRequests;
RWStructuredBuffer<RaycastResult> RaycastResults;

float3 WorldStart;
float3 WorldEnd; 
int NumSamples;

[numthreads(32, 1, 1)]
void CSMain(uint3 id : SV_DispatchThreadID) 
{
	const uint slice = 0;
	const uint i = id.x;
	
	float rayDist = i / (float) NumSamples;
	 
	float3 rayWorld = lerp(WorldStart, WorldEnd, rayDist);
    float3 rayNDC = WorldtoNDC(rayWorld, slice);
    float2 rayUV = rayNDC.xy;

	// depth compare to find closest point of intersection
    float envDepth = SampleDepth(rayUV, slice);
	RaycastResults[i].ZDepthDiff = envDepth - rayNDC.z;
	
	// world pos position
    float3 depthWorld = NDCtoWorld(float3(rayUV, envDepth), slice);
	RaycastResults[i].Position = depthWorld;
	
	// world norm
    rayUV = rayNDC.xy + float2(0.01, 0.0);
    float3 depthWorldH = NDCtoWorld(float3(rayUV, SampleDepth(rayUV, slice)), slice);

    rayUV = rayNDC.xy + float2(0.0, 0.01);
    float3 depthWorldV = NDCtoWorld(float3(rayUV, SampleDepth(rayUV, slice)), slice);
	
	float3 hDeriv = depthWorldH - depthWorld;
	float3 vDeriv = depthWorldV - depthWorld;
	
	float3 norm = -normalize(cross(hDeriv, vDeriv));
#if FLIP_UVS
	norm = -norm;
#endif
    RaycastResults[i].Normal = norm;
}
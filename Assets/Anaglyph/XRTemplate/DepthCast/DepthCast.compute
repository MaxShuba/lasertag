// https://github.com/oculus-samples/Unity-DepthAPI/issues/16

#pragma kernel CSMain
#include "Assets/Anaglyph/XRTemplate/DepthCast/DepthKit.hlsl"
//#include "Packages/com.meta.xr.depthapi.urp/Shaders/EnvironmentOcclusionURP.hlsl"

struct RaycastResult
{
	float ZDepthDiff;
	float3 Position;
	float3 Normal;
};

StructuredBuffer<float3> RaycastRequests;
RWStructuredBuffer<RaycastResult> RaycastResults;

float3 WorldStart;
float3 WorldEnd;
int NumSamples;

[numthreads(32, 1, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    const uint slice = 0;
    const uint i = id.x;
	
    const float rayDist = i / (float)NumSamples;

    const float4 rayPos = float4(lerp(WorldStart, WorldEnd, rayDist), 1);
	
	const float4 hcs = mul(unity_StereoMatrixVP[slice], rayPos);
	const float2 uv = (hcs.xy / hcs.w) * 0.5 + float2(0.5, 0.5);

	const float envDepth = SampleEnvDepthDK(uv, slice);
	
	const float4x4 matInvProj = unity_StereoMatrixInvP[slice];
	float envDepthMeters = -ApplyMatrixDK(uv, envDepth, matInvProj).z;
	// prevent depth texture edge values from reading a hit in your face
	// envDepthMeters += (envDepthMeters < 0.3) * 9999.0;
	
	float rayDepthMeters = -mul(unity_StereoMatrixV[slice], rayPos).z;
	
	RaycastResults[i].ZDepthDiff = envDepthMeters - rayDepthMeters;
	
	const float4x4 matInvViewProj = unity_StereoMatrixInvVP[slice];
	float3 worldPos = ComputeWorldSpacePositionDK(uv, envDepth, 0);
	float3 worldNorm = ComputeWorldSpaceNormalDK(uv, worldPos, slice);
	
	RaycastResults[i].Position = worldPos;
	RaycastResults[i].Normal = worldNorm;
}